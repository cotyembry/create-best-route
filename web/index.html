<!DOCTYPE html>
<html>
<head>
	<title>Create Best Route</title>
	<!-- <meta name="viewport" content="width=device-width" , initial-scale="1" , maximum-scale="1"> commented out 03-10-2018 to use the below reccommended by hammer.js docs -->
	<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1"><!-- this makes the page render like its on a phone -->
	<!-- <script type="text/javascript" src="./js/hammer.min.js"></script> -->
	
	<link rel="stylesheet" href="./node_modules/croppie/croppie.css" />
	<script src="./node_modules/croppie/croppie.js"></script>
	
	
	
	<style>
		html {
			overflow: hidden;
			position: fixed;
			/* touch-action: none; */
		}
		.hover {
			cursor: pointer;
		}
	</style>
</head>
<body>

	<!-- <div id="test"></div> -->
	<div id="CreateBestRoute" style="width: 100%; height: 100%;"></div>
	<div id="vanillaDemo"></div>
	<canvas id="canvasReference" width="100%" height="100%" style="visibility: hidden; width: 100%; height: 100%;"></canvas>


	<script type="text/javascript">
		// $(document.body).bind('CreateBestRouteProcessCrop', function() {
		// 	console.log('in truee')
		// })
		// document.body.addEventListener('CreateBestRoutProcessCrop', function() {
		// 	console.log('in truee')
		// })

		window.CreateBestRouteProcessCrop = function (e, img, topMost, rightMost, bottomMost, leftMost) {
			// var imageObj = this.props.imageReference;
			var canvas = document.getElementById('canvasReference');

			console.log(img.naturalWidth, img.naturalHeight, 'images dimensions');
			console.log('topMost, rightMost, bottomMost, leftMost', topMost, rightMost, bottomMost, leftMost);

			if (typeof img !== 'undefined') {
				// console.log('here with: ', this.props.imageReference);
				// context.drawImage(img, 50, 0, width, height);
				let context = canvas.getContext('2d'),
					destinationCanvasDx = 0,
					destinationCanvasDy = 0,
					croppedRegionWidth = leftMost - rightMost,
					croppedRegionHeight = bottomMost - topMost,
					destinationRegionWidth = croppedRegionWidth,
					destinationRegionHeight = croppedRegionHeight;

				// context.drawImage(img, e.clientX - 7, e.clientY - 7, img.naturalWidth, img.naturalHeight, destinationCanvasDx, destinationCanvasDy, img.naturalWidth, img.naturalHeight);		//these numbers being subtracted from the clientX and clientY values are perfect IF AND ONLY IF the screen's zoom is 100%, if its different these are wrong
				// context.drawImage(img, e.clientX - 79, e.clientY - 19, img.naturalWidth, img.naturalHeight, destinationCanvasDx, destinationCanvasDy, img.naturalWidth, img.naturalHeight);		//these numbers being subtracted from the clientX and clientY values are perfect IF AND ONLY IF the screen's zoom is 100%, if its different these are wrong
				// context.drawImage(img, e.clientX, e.clientY, img.naturalWidth, img.naturalHeight, destinationCanvasDx, destinationCanvasDy, img.naturalWidth, img.naturalHeight);		//these numbers being subtracted from the clientX and clientY values are perfect IF AND ONLY IF the screen's zoom is 100%, if its different these are wrong
				context.drawImage(img, e.clientX, e.clientY, croppedRegionWidth, croppedRegionHeight, destinationCanvasDx, destinationCanvasDy, img.naturalWidth, img.naturalHeight);		//these numbers being subtracted from the clientX and clientY values are perfect IF AND ONLY IF the screen's zoom is 100%, if its different these are wrong
				
				// context.beginPath();
				// context.arc(0, 0, 5, 0, 2 * Math.PI, false);
				// context.stroke();

				let png = canvas.toDataURL('image/png');
				console.log('png = ', png);
				// document.getElementById('image2').src = png;
				window.png = png;
				window.src = img.src;
				window.context = context;
				window.canvas = canvas;

				// img.src = png;

				window.img = img;

				// $(img).croppie({	//options
				// 	viewport: { width: croppedRegionWidth, height: croppedRegionHeight, type: 'square' },
				// 	boundary: { width: croppedRegionWidth, height: croppedRegionHeight },
				// 	showZoom: true
				// });

				// $(img).croppie(function() {

				// })

				/*
				var vanilla = new Croppie(document.getElementById('vanillaDemo'), {
					viewport: { width: croppedRegionWidth, height: croppedRegionHeight, type: 'square' },
					boundary: { width: croppedRegionWidth, height: croppedRegionHeight },
					showZoom: true
				});

				vanilla.bind(img).then(function () {
					vanilla.result('canvas', 'original').then(function (src) {
						console.log(src);
						window.img.src = src;
					});
				});
				*/




				// $('#x').css({
				// 	position: 'absolute',
				// 	top: topMost,
				// 	left: leftMost,
				// 	width: rightMost - leftMost,
				// 	height: bottomMost - topMost
				// })
			}
		}

		window.drawImage = function() {
			
		}

		// old logic
		// window.CreateBestRouteProcessCrop = function(e, imageObj, onLoadEvent, width, height) {
		// 	// var imageObj = this.props.imageReference;
		// 	var canvas = document.getElementById('canvasReference'),
		// 		img = imageObj;	
		// 	console.log('here with: ', e, imageObj, canvas, 'onLoadEvent = ', onLoadEvent);
		// 	if (typeof imageObj !== 'undefined') {
		// 		// console.log('here with: ', this.props.imageReference);
		// 		// canvas.width = coords.w;
		// 		// canvas.width = '100px';
		// 		// canvas.height = coords.h;
		// 		// canvas.height = '100px';
		// 		console.log('ORIGINAL = ', img.src)
		// 		var context = canvas.getContext('2d');
		// 		// context.drawImage(imageObj, coords.x, coords.y, coords.w, coords.h, 0, 0, canvas.width, canvas.height);
		// 		context.drawImage(img, 50, 0, width, height);
		// 		var png = canvas.toDataURL('image/png');
		// 		img.src = png;
		// 		console.log('png = ', png);
		// 		/*
		// 		var context = document.getElementById('canvas1').getContext("2d");
		// 		var img = new Image();
		// 		img.onload = function () {
		// 			context.drawImage(img, 0, 0);
		// 		}
		// 		img.src = "images/watermelon-duck.png";
		// 		*/
		// 	}
		// }
		
	
	</script>

	<script type="text/javascript" src="./dist/bundle.js"></script>

</body>
</html>